<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/league.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<style>
		code {
			border-radius: 10px;
		}

		code table {
			margin: 10px !important;
		}

		::-webkit-scrollbar {display: none;}
	</style>
	<div class="reveal">
		<div class="slides">

			<!-- SLIDES BEGINING  -->

			<!-- SECTION #1 -->
			<section data-background-video="video-banner.mp4" data-background-video-loop data-background-video-muted>
				<p style="font-family: monospace;">PATRONES DE DISEÑO DE</p>
				<h2 class="r-fit-text">software</h2>
				<p><span style="display: inline-block;" class="fragment  fade-up">| Creacionales |&nbsp;</span><span
						style="display: inline-block;" class="fragment fade-up">&nbsp;| Estructurales |</span><span
						style="display: inline-block;" class="fragment fade-up">&nbsp;| Comportamiento |</span></p>
			</section>

			<!-- SECTION #2 -->
			<section>
				<section data-transition="slide" data-background="#1d89b3">
					<h2>Patrones Creacionales</h2>
					<p>Los patrones de creación brindan mecanismos para la creación de objetos que aumentan la flexibilidad y la reutilización del código existente. Estos patrones permiten al programa decidir qué objetos deben crearse para un caso de uso específico.</p>
				</section>
				<section>
					<span>| Abstract Factory |</span>
					<p style="font-size: xx-large;">Este patrón proporciona una forma de encapsular la creación de objetos y permite que el código cliente trabaje con las interfaces de los productos, en lugar de trabajar directamente con clases concretas. Esto promueve la flexibilidad y el desacoplamiento en el diseño de software.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/abstract-factory/solution1.png?id=71f2018d8bb443b9cce90d57110675e3" />
				</section>
				<section>
					<span>| Builder Patterns |</span>
					<p style="font-size: xx-large;">El patrón Builder permite una mayor flexibilidad y extensibilidad en la construcción de objetos complejos, ya que se pueden definir diferentes Builders para crear diferentes representaciones del mismo objeto. Además, ayuda a evitar la complejidad de tener un constructor con muchos parámetros y facilita la legibilidad del código.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/builder/problem1.png?id=11e715c5c97811f848c48e0f399bb05e" />
				</section>
				<section>
					<span>| Factory Method |</span>
					<p style="font-size: xx-large;">El propósito del Factory Method es permitir que una clase delegue la creación de objetos a sus subclases. En lugar de que la clase principal instancie directamente los objetos concretos, se define un método de fábrica abstracto en la clase principal que las subclases deben implementar. Cada subclase puede decidir qué tipo de objeto concreto crear y devolver a través del método de fábrica.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/factory-method/factory-method-es.png?id=4040e2911292e5a623f10e36c380459d" />
				</section>
				<section>
					<span>| Prototype |</span>
					<p style="font-size: xx-large;">El propósito del patrón Prototype es permitir la creación de nuevos objetos mediante la clonación de un objeto existente en lugar de crear nuevos objetos desde cero. Esto evita la dependencia del código en las clases concretas de los objetos y permite la creación de nuevos objetos sin conocer los detalles de su implementación.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/prototype/prototype.png?id=e912b1ada20bbf7b2ffc09e93b9fab20" />
				</section>
				<section>
					<span>| Singleton |</span>
					<p style="font-size: xx-large;">El patrón Singleton restringe la creación de instancias de una clase a un único objeto y proporciona un punto de acceso global a dicha instancia. El propósito de este patrón es garantizar que solo exista una única instancia de una clase y proporcionar una forma de acceder a ella desde cualquier parte del código.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://img2.freepng.es/20180710/fay/kisspng-singleton-pattern-software-design-pattern-system-o-singleton-pattern-5b4452e6b087a6.7597909315312043267231.jpg" />
				</section>
			</section>

			<!-- SECTION #3 -->
			<section>
				<section data-transition="slide" data-background="#b302b3">
					<h2>Patrones Estructurales</h2>
					<p>Proporcionan soluciones eficientes para componer clases y estructuras de objetos. Utilizan el concepto de herencia para componer interfaces y definir maneras de componer objetos para obtener nuevas funcionalidades. Los patrones estructurales explican cómo ensamblar objetos y clases en estructuras más grandes mientras se mantiene la flexibilidad y eficiencia de estas estructuras</p>
				</section>
				<section>
					<span>| Adapter |</span>
					<p style="font-size: xx-large;">Este patrón permite que los objetos con interfaces incompatibles colaboren. Convierte la interfaz de una clase en otra que espera un cliente, permitiendo así que las clases con interfaces diferentes trabajen juntas.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/adapter/solution-es.png?id=2b1c418b5b85e53a37ea4bdad18064d6" />
				</section>
				<section>
					<span>| Bridge |</span>
					<p style="font-size: xx-large;">Este patrón desacopla una abstracción de su implementación para que puedan variar independientemente. Permite dividir una clase grande o un grupo de clases estrechamente relacionadas en dos jerarquías separadas (abstracción e implementación) que pueden desarrollarse independientemente la una de la otra.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/bridge/solution-es.png?id=ea5b0ca5eb04228838c3079bd7d877d6" />
				</section>
				<section>
					<span>| Composite |</span>
					<p style="font-size: xx-large;">Este patrón permite componer objetos en estructuras de árbol y trabajar con esas estructuras como si fueran objetos individuales. Es especialmente útil cuando se necesita realizar operaciones en estructuras de datos dinámicas con jerarquías complejas.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/composite/problem-es.png?id=3b02eaf4b7744eb05b261ac48d3d3e4a" />
				</section>
				<section>
					<span>| Decorator |</span>
					<p style="font-size: xx-large;">Este patrón permite añadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades. Agrega responsabilidades adicionales a un objeto de manera dinámica y permite extender funcionalidades de una clase sin tener que recurrir a la herencia.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/decorator/decorator.png?id=710c66670c7123e0928d3b3758aea79e" />
				</section>
				<section>
					<span>| Facade |</span>
					<p style="font-size: xx-large;">Este patrón proporciona una interfaz simplificada a una biblioteca, un framework o cualquier otro grupo complejo de clases. Provee una interfaz unificada para un grupo de interfaces en un subsistema, de manera que esta funcione como una interfaz de alto nivel que hace al resto de las interfaces fácil de usar.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/facade/facade.png?id=1f4be17305b6316fbd548edf1937ac3b" />
				</section>
				<section>
					<span>| Flyweight |</span>
					<p style="font-size: xx-large;">Este patrón permite mantener más objetos dentro de la cantidad disponible de memoria RAM compartiendo las partes comunes del estado entre varios objetos en lugar de mantener toda la información en cada objeto. Es útil para la creación eficiente de numerosos objetos de grano fino.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/flyweight/flyweight.png?id=e34fbacb847dd609b5e68aaf252c4db0" />
				</section>
				<section>
					<span>| Proxy |</span>
					<p style="font-size: xx-large;">Este patrón proporciona un sustituto o marcador de posición para otro objeto. Un proxy controla el acceso al objeto original, permitiendo hacer algo antes o después de que la solicitud llegue al objeto original.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed.png?id=e56d420f31925b3d41348c5036d3cd64" />
				</section>
			</section>
			<!-- SECTION #4 -->
			<section>
				<section data-transition="slide" data-background="#ffff00">
					<h2>Patrones De Comportamiento</h2>
					<p>Los patrones de comportamiento son aquellos patrones que se centran en los algoritmos y la asignación de responsabilidades entre los objetos. Se ocupan de la comunicación entre los objetos, cómo interactúan y distribuyen la funcionalidad.</p>
				</section>
				<section>
					<span>| Chain of Responsibility |</span>
					<p style="font-size: xx-large;">Este patrón permite pasar solicitudes a lo largo de una cadena de manejadores. Al recibir una solicitud, cada manejador decide si la procesa o si la pasa al siguiente manejador de la cadena.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution1-es.png?id=122092268f688aa2015b2f20dabafb89" />
				</section>
				<section>
					<span>| Command |</span>
					<p style="font-size: xx-large;">Este patrón de diseño convierte una solicitud en un objeto independiente que contiene toda la información sobre la solicitud. Esta transformación permite parametrizar los métodos con diferentes solicitudes, retrasar o poner en cola la ejecución de una solicitud y soportar operaciones que no se pueden realizar.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/command/command-es.png?id=aa52c5ce63cbff0adf7dfcc5909f7eb4" />
				</section>
				<section>
					<span>| Interpreter |</span>
					<p style="font-size: xx-large;">Este patrón de diseño especifica cómo evaluar sentencias en un lenguaje. El patrón de intérprete básico utiliza una clase para representar cada símbolo gramatical.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/index/patterns-i1.png?id=ccf20fa726f8a7349011e4dff2979773" />
				</section>
				<section>
					<span>| Iterator |</span>
					<p style="font-size: xx-large;">Este patrón proporciona una forma de acceder a los elementos de un objeto agregado de manera secuencial sin exponer su representación subyacente. Es especialmente útil para recorrer una estructura de datos.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/iterator/iterator-es.png?id=79d47b82a1e72adaaa70d8e1a3b10a4e" />
				</section>
				<section>
					<span>| Mediator |</span>
					<p style="font-size: xx-large;">El patrón de mediador define un objeto que encapsula cómo un conjunto de objetos interactúan. Promueve el acoplamiento débil al evitar que los objetos se refieran entre sí explícitamente, lo que permite variar sus interacciones de forma independiente.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/mediator/example.png?id=3151c153533e816e226be0ef977211e8" />
				</section>
				<section>
					<span>| Memento |</span>
					<p style="font-size: xx-large;">Este patrón proporciona la capacidad de restaurar un objeto a su estado anterior (deshacer a través de retroceso).</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/memento/memento-es.png?id=425d7fafd404116e99e93c3d8a04ec89" />
				</section>
				<section>
					<span>| Observer |</span>
					<p style="font-size: xx-large;">Este patrón define una dependencia uno a muchos entre objetos para que cuando un objeto cambie de estado, todos sus dependientes sean notificados y actualizados automáticamente.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/observer/observer.png?id=6088e31e1b0d4a417506a66614dcf065" />
				</section>
				<section>
					<span>| State |</span>
					<p style="font-size: xx-large;">Este patrón permite a un objeto alterar su comportamiento cuando su estado interno cambia. El objeto parecerá cambiar su clase.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/state/state-es.png?id=03f2a3a86f4b58cc21b4c8c152d6c0ec" />
				</section>
				<section>
					<span>| Strategy |</span>
					<p style="font-size: xx-large;">Este patrón de diseño define una familia de algoritmos, encapsula cada uno, y los hace intercambiables. La estrategia permite que el algoritmo varíe independientemente de los clientes que lo utilizan.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-es.png?id=1cf442d8c2d5d78f214499bb72dfdc72" />
				</section>
				<section>
					<span>| Template Method |</span>
					<p style="font-size: xx-large;">En este patrón, se define el esqueleto de un algoritmo en una operación, aplazando algunos pasos a las subclases. El método de plantilla permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/diagrams/template-method/structure.png?id=924692f994bff6578d8408d90f6fc459" />
				</section>
				<section>
					<span>| Visitor |</span>
					<p style="font-size: xx-large;">Este patrón de diseño representa una operación que se realiza en los elementos de una estructura de objetos. El patrón visitante permite definir una nueva operación sin cambiar las clases de los elementos en los que opera.</p>
				</section>
				<section>
					<span>| EJEMPLO |</span>
					<img src="https://refactoring.guru/images/patterns/content/visitor/visitor-comic-1.png?id=7ee4fa8800f7c4df4e1aa3b1aca2b7f1" />
				</section>
			</section>

			<!-- SLIDES END -->

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>
